import torch
import torchvision.transforms as T
import torchvision.models.segmentation as segmentation
import cv2
import numpy as np
import matplotlib.pyplot as plt


# -----------------------------
# DeepLabV3 + GRU (frozen GRU)
# -----------------------------
class DeepLabV3_FrozenGRU(nn.Module):
    def __init__(self, num_classes=21):
        super().__init__()
        # Load pretrained DeepLabV3
        base_model = segmentation.deeplabv3_resnet101(
            weights=segmentation.DeepLabV3_ResNet101_Weights.COCO_WITH_VOC_LABELS_V1
        )
        self.backbone = base_model.backbone
        self.classifier = base_model.classifier  # use pretrained head

        # Add a GRU but freeze it (not trained, not used yet)
        self.gru = nn.GRU(input_size=2048, hidden_size=512, batch_first=True)
        for p in self.gru.parameters():
            p.requires_grad = False

        # flag to control whether GRU is used
        self.use_gru = False  # change to True later if you want to activate it

    def forward(self, x):
        # Get DeepLab features
        features = self.backbone(x)['out']  # [B, 2048, H, W]
        if self.use_gru:
            B, C, H, W = features.shape
            seq = features.view(B, C, -1).permute(0, 2, 1)  # [B, H*W, C]
            with torch.no_grad():  # ensure frozen
                gru_out, _ = self.gru(seq)
            features = gru_out.permute(0, 2, 1).view(B, 512, H, W)
        return {'out': self.classifier(features)}


# -----------------------------
# Load frozen-GRU model
# -----------------------------
model = DeepLabV3_FrozenGRU().eval()

# -----------------------------
# Image preprocessing
# -----------------------------
image_path = "/pug.jpg"
img = cv2.imread(image_path)
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

transform = T.Compose([
    T.ToPILImage(),
    T.Resize(520),
    T.ToTensor(),
    T.Normalize(mean=[0.485, 0.456, 0.406],
                std=[0.229, 0.224, 0.225]),
])
input_tensor = transform(img).unsqueeze(0)

# -----------------------------
# Inference
# -----------------------------
with torch.no_grad():
    output = model(input_tensor)['out'][0]
pred_mask = output.argmax(0).byte().cpu().numpy()

# -----------------------------
# Visualization
# -----------------------------
VOC_COLORMAP = np.array([
    (0, 0, 0), (128, 0, 0), (0, 128, 0), (128, 128, 0), (0, 0, 128),
    (128, 0, 128), (0, 128, 128), (128, 128, 128), (64, 0, 0), (192, 0, 0),
    (64, 128, 0), (192, 128, 0), (64, 0, 128), (192, 0, 128), (64, 128, 128),
    (192, 128, 128), (0, 64, 0), (128, 64, 0), (0, 192, 0), (128, 192, 128),
    (0, 64, 128)
])

color_mask = VOC_COLORMAP[pred_mask]
color_mask = cv2.resize(color_mask, (img.shape[1], img.shape[0]), interpolation=cv2.INTER_NEAREST)

# Convert color_mask to the same data type as img (uint8) BEFORE addWeighted
color_mask = color_mask.astype(img.dtype)

alpha = 0.6
overlayed = cv2.addWeighted(img, 1 - alpha, color_mask, alpha, 0)

plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.imshow(img)
plt.title("Original Image")
plt.axis("off")

plt.subplot(1, 2, 2)
plt.imshow(overlayed)
plt.title("Segmentation Overlay")
plt.axis("off")

plt.show()
